gofumpt -w .
cmp foo.go foo.go.golden

-- foo.go --
package p

func _() {
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10); err != nil {
		panic(err)
	}

	// Tiny arguments to ensure the length calculation is right.
	if err := f(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10); err != nil {
		panic(err)
	}

	// These wouldn't take significantly less horizontal space if split.
	f(x, "one single very very very very very very very very very very very very very very very very long literal")
	if err := f(x, "one single very very very very very very very very very very very very very very very very long literal"); err != nil {
		panic(err)
	}
	{
		{
			{
				{
					println("first", "one single very very very very very very very very very very very very very long literal")
				}
			}
		}
	}

	// Allow splitting at the start of sub-lists too.
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, someComplex{argument7, argument8, argument9}); err != nil {
		panic(err)
	}
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, &someComplex{argument7, argument8, argument9}); err != nil {
		panic(err)
	}
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, []someSlice{argument7, argument8, argument9}); err != nil {
		panic(err)
	}
}

// This line goes beyond the limit of 100, but splitting it would leave the
// following line with just 20 non-indentation characters. Not worth it.
func LongButNotWorthSplitting(argument1, argument2, argument3, argument4, argument5, argument6, argument7 int) bool {
}

// Never split result parameter lists, as that could easily add confusion with
// extra input parameters.
func NeverSplitResults(argument1, argument2, argument3, argument4, argument5 int) (result1 int, result2, result3, result4, result5 bool) {
}
-- foo.go.golden --
package p

func _() {
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, argument7,
		argument8, argument9, argument10); err != nil {
		panic(err)
	}

	// Tiny arguments to ensure the length calculation is right.
	if err := f(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, 0,
		1, 2, 3, 4, 5, 6, 7, 8, 9, 10); err != nil {
		panic(err)
	}

	// These wouldn't take significantly less horizontal space if split.
	f(x, "one single very very very very very very very very very very very very very very very very long literal")
	if err := f(x, "one single very very very very very very very very very very very very very very very very long literal"); err != nil {
		panic(err)
	}
	{
		{
			{
				{
					println("first", "one single very very very very very very very very very very very very very long literal")
				}
			}
		}
	}

	// Allow splitting at the start of sub-lists too.
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, someComplex{
		argument7, argument8, argument9}); err != nil {
		panic(err)
	}
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, &someComplex{
		argument7, argument8, argument9}); err != nil {
		panic(err)
	}
	if err := f(argument1, argument2, argument3, argument4, argument5, argument6, []someSlice{
		argument7, argument8, argument9}); err != nil {
		panic(err)
	}
}

// This line goes beyond the limit of 100, but splitting it would leave the
// following line with just 20 non-indentation characters. Not worth it.
func LongButNotWorthSplitting(argument1, argument2, argument3, argument4, argument5, argument6, argument7 int) bool {
}

// Never split result parameter lists, as that could easily add confusion with
// extra input parameters.
func NeverSplitResults(argument1, argument2, argument3, argument4, argument5 int) (result1 int, result2, result3, result4, result5 bool) {
}
